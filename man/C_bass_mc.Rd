% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/C_bass_mc.R
\name{C_bass_mc}
\alias{C_bass_mc}
\title{Estimate the Constantine Matrix with BASS using Monte Carlo}
\usage{
C_bass_mc(
  mod,
  n_mc = 10000,
  prior = NULL,
  mcmc.use = NULL,
  use_native_scale = FALSE,
  func.use = NULL,
  func.true = NULL,
  pca_method = 2,
  verbose = FALSE
)
}
\arguments{
\item{mod}{a fitted BASS model. The output of the bass() or bassPCA() functions.}

\item{n_mc}{number of Monte Carlo samples}

\item{prior}{A function providing samples of x. Or, alternatively, a list, like one returned by the \code{build_prior()} function. See the documentation for details.}

\item{mcmc.use}{a vector of indices telling which mcmc draws to use}

\item{use_native_scale}{logical (default `TRUE`). Determines the scale of the inputs for computing the \( C \)-matrix. When `TRUE`, the \( C \)-matrix is computed on the original (native) scale of the input variables. When `FALSE`, the \( C \)-matrix corresponds to the inputs normalized to the \([0, 1]\) range, as used internally by BASS. This also affects derived quantities, such as activity scores..}

\item{func.use}{a vector indicating which values of the functional variable to compute C for, if applicable}

\item{func.true}{An optional vector of values for the functional variable in bassPCA. Should have length equal to nrow(bassPCA$dat$basis).}

\item{pca_method}{takes value 1 or 2 to indicate which method should be used for estimating C. See details.}

\item{verbose}{logical; should progress be displayed?}
}
\value{
A list representing the posterior distribution of the Constantine matrix.
}
\description{
Monte Carlo Estimator of the C matrix using a BASS model
}
\details{
The C matrices are computed using inputs which are scaled to (0, 1). The \code{use_native_scale} flag indicates whether the C matrix should be transformed to the native space before returning.

The \code{func.use} argument is used only if \code{mod} is fit to functional response data (using \code{bass()} with \code{xx.func} specified or by using \code{bassPCA}). In the latter case, the functional input is assumed to be between 0 and 1.

The \code{pca_method} argument is used only when \code{mod} has class bassBasis. When set to 1 (the default), the decomposition theorem is used to estimate C. Otherwise, the model list is converted to a single model using \code{basslc2bass} and C is found directly. Method 1 is typically faster (especially for multiple func.use), but method 2 gives more flexibility in the choice of prior.
}
\examples{
# FRIEDMAN FUNCTION
# First input is treated as functional
# Use p=5, so there is one inert variable
f <- function(x, t) {
  10 * sin(pi * t * x[1]) + 20 * (x[2] - 0.5)^2 + 10 * x[3] + 5 * x[4]
}

# ===========================================
#        GENERATE DATA
# ===========================================
XX <- lhs::randomLHS(500, 5)
y1 <- apply(XX, 1, f, t = 0.5)
xfunc <- seq(0, 1, length.out = 20)
yfunc <- t(apply(XX, 1, f, t = xfunc))

Xtest <- lhs::randomLHS(100, 5)
ytest <- apply(Xtest, 1, f, t = 0.5)

# ===========================================
#        CASE 1: Univariate BASS
# ===========================================
mod1 <- bass(XX, y1)
C1 <- C_bass_mc(mod1)

}
