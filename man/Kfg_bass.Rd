% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Kfg_bass.R
\name{Kfg_bass}
\alias{Kfg_bass}
\title{Estimate the Co-Zahm Matrix with BASS}
\usage{
Kfg_bass(
  mod1,
  mod2,
  prior = NULL,
  prior_func = function(tt) dunif(tt),
  mcmc.use = NULL,
  use_native_scale = FALSE,
  func.use = NULL,
  func.true = NULL,
  pca_method = 2,
  verbose = FALSE
)
}
\arguments{
\item{mod1}{a fitted functional BASS model, or a list of univariate bass models for function 1.}

\item{mod2}{a fitted functional BASS model, or a list of univariate bass models for function 2.}

\item{prior}{a list, like one returned by the \code{build_prior()} function. See the documentation for details.}

\item{prior_func}{prior for the functional variable. Either a function over 0 to 1 (assumed to integrate to 1) or a vector with the same length as \code{func.use}.}

\item{mcmc.use}{a vector of indices telling which mcmc draws to use}

\item{use_native_scale}{logical (default `TRUE`). Determines the scale of the inputs for computing the \( C \)-matrix. When `TRUE`, the \( C \)-matrix is computed on the original (native) scale of the input variables. When `FALSE`, the \( C \)-matrix corresponds to the inputs normalized to the \([0, 1]\) range, as used internally by BASS. This also affects derived quantities, such as activity scores..}

\item{func.use}{a vector indicating which values of the functional variable to compute C for, if applicable}

\item{func.true}{An optional vector of values for the functional variable in bassPCA. Should have length equal to nrow(bassPCA$dat$basis).}

\item{pca_method}{takes value 1 or 2 to indicate which method should be used for estimating C. Ignored unless \code{class(mod) == "bassBasis"}.}

\item{verbose}{logical; should progress be displayed?}
}
\value{
A list representing the posterior distribution of the Constantine matrix.
}
\description{
Closed form estimator of the Co-Zahm matrix using a BASS model
}
\details{
The K matrix is C(t) integrated over t with respect to a prior rho_t. In practice, this is equivalent to the Zahm matrix for multivariate response with a diagonal R.
}
\examples{
# FRIEDMAN FUNCTION
# First input is treated as functional
# Use p=5, so there is one inert variable
f <- function(x, t) {
  10 * sin(pi * t * x[1]) + 20 * (x[2] - 0.5)^2 + 10 * x[3] + 5 * x[4]
}

# ===========================================
#        GENERATE DATA
# ===========================================
XX <- lhs::randomLHS(500, 5)
y1 <- apply(XX, 1, f, t = 0.5)
xfunc <- seq(0, 1, length.out = 20)
yfunc <- t(apply(XX, 1, f, t = xfunc))

Xtest <- lhs::randomLHS(100, 5)
ytest <- apply(Xtest, 1, f, t = 0.5)

# ===========================================
#        CASE 1: Univariate BASS
# ===========================================
mod1 <- bass(XX, y1)
C1 <- C_bass(mod1)

# ===========================================
#      CASE 2: Augmented BASS (fixed t)
# ===========================================
mod2_full <- bass(XX, yfunc, xx.func = xfunc)
mod2 <- bassfunc2bass_fixed_t(mod2_full, 0.5)
C2 <- C_bass(mod2)
C2b <- C_bass(mod2_full, func.use=0.5)

# ===========================================
#      CASE 3: PCA BASS (fixed t)
# ===========================================
mod3_full <- bassPCA(XX, yfunc)
mod3 <- bassPCA2bass_fixed_t(mod3_full, 0.5)
C3 <- C_bass(mod3)
C3b <- C_bass(mod3_full, func.use=0.5)

}
