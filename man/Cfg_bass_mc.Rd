% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/C_bass_mc.R
\name{Cfg_bass_mc}
\alias{Cfg_bass_mc}
\title{Estimate the Constantine Matrix with BASS using Monte Carlo}
\usage{
Cfg_bass_mc(
  mod1,
  mod2,
  prior = NULL,
  mcmc.use = NULL,
  use_native_scale = FALSE,
  func.use = NULL,
  func.true = NULL,
  pca_method = 2,
  verbose = FALSE
)
}
\arguments{
\item{mod1}{a fitted BASS model for the first function.}

\item{mod2}{a fitted BASS model for the second function.}

\item{prior}{a list, like one returned by the \code{build_prior()} function. See the documentation for details.}

\item{mcmc.use}{a two-column matrix of MCMC indices corresponding to mod1 and mod2 respectively.}

\item{use_native_scale}{logical (default `TRUE`). Determines the scale of the inputs for computing the \( C \)-matrix. When `TRUE`, the \( C \)-matrix is computed on the original (native) scale of the input variables. When `FALSE`, the \( C \)-matrix corresponds to the inputs normalized to the \([0, 1]\) range, as used internally by BASS. This also affects derived quantities, such as activity scores..}

\item{func.use}{a vector indicating which values of the functional variable to compute C for, if applicable}

\item{pca_method}{takes value 1 or 2 to indicate which method should be used for estimating C. See details.}

\item{verbose}{logical; should progress be displayed?}
}
\value{
A list representing the posterior distribution of the Constantine matrix.
}
\description{
Monte Carlo estimator of the C matrix using a BASS model
}
\details{
The C matrices are computed using inputs which are scaled to (0, 1). The \code{use_native_scale} flag indicates whether the C matrix should be transformed to the native space before returning.

The \code{func.use} argument is used only if \code{mod} is fit to functional response data (using \code{bass()} with \code{xx.func} specified or by using \code{bassPCA}). In the latter case, the functional input is assumed to be between 0 and 1.

The \code{pca_method} argument is used only when \code{mod} has class bassBasis. When set to 1 (the default), the decomposition theorem is used to estimate C. Otherwise, the model list is converted to a single model using \code{lcbass2bass} and C is found directly. Method 1 is typically faster (especially for multiple func.use), but method 2 gives more flexibility in the choice of prior.
}
\examples{
# FRIEDMAN FUNCTION AND SECONDARY FUNCTION
# First input is treated as functional
# Use p=5, so there is one inert variable
f <- function(x, t) {
  10 * sin(pi * t * x[1]) + 20 * (x[2] - 0.5)^2 + 10 * x[3] + 5 * x[4]
}
g <- function(x, t) {
  5 * sin(2 * pi * t * x[1]) + 15 * (x[3] - 0.3)^2 + 8 * x[4] + 3 * x[5]
}

# ===========================================
#        GENERATE DATA
# ===========================================
XX <- lhs::randomLHS(500, 5)
y1_f <- apply(XX, 1, f, t = 0.5)
y1_g <- apply(XX, 1, g, t = 0.5)
xfunc <- seq(0, 1, length.out = 20)
yfunc_f <- t(apply(XX, 1, f, t = xfunc))
yfunc_g <- t(apply(XX, 1, g, t = xfunc))

Xtest <- lhs::randomLHS(100, 5)
ytest_f <- apply(Xtest, 1, f, t = 0.5)
ytest_g <- apply(Xtest, 1, g, t = 0.5)

# ===========================================
#        CASE 1: Univariate BASS
# ===========================================
mod1_f <- bass(XX, y1_f)
mod1_g <- bass(XX, y1_g)
C1_fg <- Cfg_bass_mc(mod1_f, mod1_g)
}
